#!/bin/bash
# git-cloud: Manage git repos in cloud-synced folders with local .git
# https://github.com/jgorostegui/git-cloud

set -e

GIT_DIRS="${GIT_DIRS:-$HOME/.git-dirs}"
CLOUD_DIRS="${CLOUD_DIRS:-$HOME/GoogleDrive:$HOME/Dropbox:$HOME/OneDrive}"
REMOTE_FILE=".git-remote"
VERSION="1.3.0"

# Colors
red()    { echo -e "\033[0;31m$1\033[0m"; }
green()  { echo -e "\033[0;32m$1\033[0m"; }
yellow() { echo -e "\033[1;33m$1\033[0m"; }
blue()   { echo -e "\033[0;34m$1\033[0m"; }

# Iterate over CLOUD_DIRS (colon-separated)
each_cloud_dir() {
    local IFS=':'
    for dir in $CLOUD_DIRS; do
        [ -d "$dir" ] && echo "$dir"
    done
}

# Get git-dir path using mirror structure
# ~/GoogleDrive/dev/repo → ~/.git-dirs/GoogleDrive/dev/repo
get_git_dir() {
    local repo_path="$1"
    # Remove $HOME prefix, keep the rest of the structure
    local relative="${repo_path#"$HOME"/}"
    echo "$GIT_DIRS/$relative"
}

# Clone repo with separate git dir
cmd_clone() {
    local url="$1"
    local dest="$2"

    if [ -z "$url" ]; then
        echo "Usage: git-cloud clone <url> [destination]"
        echo ""
        echo "Example: git-cloud clone git@github.com:user/repo.git ~/GoogleDrive/dev/repo"
        return 1
    fi

    # Default destination from URL
    if [ -z "$dest" ]; then
        dest="$(basename "$url" .git)"
    fi

    # Resolve to absolute path
    dest="$(mkdir -p "$(dirname "$dest")" && cd "$(dirname "$dest")" && pwd)/$(basename "$dest")"

    if [ -e "$dest" ]; then
        red "Error: Destination already exists: $dest"
        return 1
    fi

    local git_dir
    git_dir=$(get_git_dir "$dest")

    if [ -e "$git_dir" ]; then
        red "Error: Git dir already exists: $git_dir"
        echo "Remove it first: rm -rf \"$git_dir\""
        return 1
    fi

    mkdir -p "$(dirname "$git_dir")"

    blue "Cloning with separate git dir..."
    echo "  URL: $url"
    echo "  Working tree: $dest"
    echo "  Git dir: $git_dir"
    echo ""

    git clone --separate-git-dir="$git_dir" "$url" "$dest"

    # Save remote URL for other machines
    echo "$url" > "$dest/$REMOTE_FILE"

    echo ""
    green "Done!"
    echo ""
    echo "Created $REMOTE_FILE with remote URL."
    echo "Tip: Add '$REMOTE_FILE' to your global .gitignore"
}

# Setup git for a folder that was synced (no .git yet)
cmd_setup() {
    local arg1="$1"
    local arg2="$2"
    local url=""
    local repo_path=""

    # Parse arguments
    if [ -z "$arg1" ]; then
        repo_path="."
    elif [ -d "$arg1" ] || [ "$arg1" = "." ]; then
        repo_path="$arg1"
        url="$arg2"
    else
        url="$arg1"
        repo_path="${arg2:-.}"
    fi

    # Resolve path
    repo_path="$(cd "$repo_path" 2>/dev/null && pwd)" || {
        red "Error: Directory does not exist"
        return 1
    }

    # Try to read URL from .git-remote
    if [ -z "$url" ] && [ -f "$repo_path/$REMOTE_FILE" ]; then
        url="$(cat "$repo_path/$REMOTE_FILE")"
        blue "Read URL from $REMOTE_FILE: $url"
    fi

    if [ -z "$url" ]; then
        red "Error: No URL provided and no $REMOTE_FILE found"
        echo ""
        echo "Usage: git-cloud setup <url> [path]"
        echo "   or: git-cloud setup [path]  (if $REMOTE_FILE exists)"
        return 1
    fi

    # Check if already set up
    if [ -d "$repo_path/.git" ]; then
        red "Error: .git directory exists. Use 'migrate' to move it outside."
        return 1
    fi

    if [ -f "$repo_path/.git" ]; then
        local pointer
        pointer="$(cat "$repo_path/.git")"
        if [[ "$pointer" == gitdir:* ]]; then
            local existing_dir="${pointer#gitdir: }"
            if [ -d "$existing_dir" ]; then
                green "Already set up: $existing_dir"
                return 0
            fi
            green "Pointer from another machine detected, configuring for this machine..."
        fi
    fi

    local git_dir
    git_dir=$(get_git_dir "$repo_path")

    mkdir -p "$(dirname "$git_dir")"

    blue "Setting up git..."
    echo "  Working tree: $repo_path"
    echo "  Git dir: $git_dir"
    echo "  Remote: $url"
    echo ""

    # Clone bare
    echo "Fetching git data..."
    git clone --bare "$url" "$git_dir" || {
        red "Clone failed"
        rm -rf "$git_dir"
        return 1
    }

    # Configure for working tree
    git --git-dir="$git_dir" config --unset core.bare
    git --git-dir="$git_dir" config core.worktree "$repo_path"

    # Configure remote tracking (bare clone doesn't set this up)
    git --git-dir="$git_dir" config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
    git --git-dir="$git_dir" fetch origin 2>/dev/null || true

    # Set up branch tracking
    local default_branch
    default_branch=$(git --git-dir="$git_dir" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
    git --git-dir="$git_dir" branch --set-upstream-to="origin/$default_branch" "$default_branch" 2>/dev/null || true

    # Create .git pointer file
    echo "gitdir: $git_dir" > "$repo_path/.git"

    # Save URL if not present
    if [ ! -f "$repo_path/$REMOTE_FILE" ]; then
        echo "$url" > "$repo_path/$REMOTE_FILE"
    fi

    # Sync index with working tree
    echo ""
    yellow "Aligning tracked files with HEAD from remote..."
    yellow "(Untracked files like .env are not affected)"

    local changes
    changes=$(git -C "$repo_path" status --porcelain 2>/dev/null | grep -vc "^??" || echo "0")
    if [ "$changes" -gt 0 ]; then
        yellow "Found $changes tracked file(s) differing from remote:"
        git -C "$repo_path" status --short 2>/dev/null | grep -v "^??" | head -10
        [ "$changes" -gt 10 ] && echo "  ... and $((changes - 10)) more"
    fi

    git -C "$repo_path" reset HEAD -- . 2>/dev/null || true

    # Fix executable permissions lost by cloud sync
    local mode_changes
    mode_changes=$(git -C "$repo_path" diff --summary 2>/dev/null | grep "mode change 100755 => 100644" || true)
    if [ -n "$mode_changes" ]; then
        echo ""
        blue "Fixing executable permissions lost by cloud sync..."
        while IFS= read -r line; do
            local file
            file="${line##*mode change 100755 => 100644 }"
            if [ -n "$file" ] && [ -f "$repo_path/$file" ]; then
                chmod +x "$repo_path/$file"
                echo "  chmod +x $file"
            fi
        done <<< "$mode_changes"
    fi

    echo ""
    green "Done!"
    git -C "$repo_path" status --short --branch
}

# Migrate existing repo (move .git outside)
cmd_migrate() {
    local repo_path="${1:-.}"
    repo_path="$(cd "$repo_path" && pwd)"

    if [ ! -d "$repo_path/.git" ]; then
        if [ -f "$repo_path/.git" ]; then
            green "Already migrated (using gitdir pointer)"
            cat "$repo_path/.git"
            return 0
        fi
        red "Error: No .git found in $repo_path"
        return 1
    fi

    local git_dir
    git_dir=$(get_git_dir "$repo_path")

    if [ -e "$git_dir" ]; then
        red "Error: Git dir already exists: $git_dir"
        return 1
    fi

    # Get remote URL before moving
    local url
    url=$(git -C "$repo_path" remote get-url origin 2>/dev/null || true)

    blue "Migrating..."
    echo "  From: $repo_path/.git"
    echo "  To: $git_dir"
    echo ""

    mkdir -p "$(dirname "$git_dir")"

    # Move .git to new location
    mv "$repo_path/.git" "$git_dir"

    # Create pointer file
    echo "gitdir: $git_dir" > "$repo_path/.git"

    # Configure worktree
    git --git-dir="$git_dir" config core.worktree "$repo_path"

    # Save remote URL
    if [ -n "$url" ] && [ ! -f "$repo_path/$REMOTE_FILE" ]; then
        echo "$url" > "$repo_path/$REMOTE_FILE"
        echo "Saved remote URL to $REMOTE_FILE"
    fi

    echo ""
    green "Done!"
    git -C "$repo_path" status --short --branch
}

# Show status of repos in cloud folders
cmd_status() {
    echo "Scanning cloud folders..."
    echo ""

    local found=0

    while IFS= read -r cloud_dir; do
        local has_repos=0

        while IFS= read -r item; do
            [ -e "$item" ] || continue

            local repo_path
            repo_path="$(dirname "$item")"
            local name="${repo_path#"$cloud_dir"/}"

            if [ $has_repos -eq 0 ]; then
                blue "=== $cloud_dir ==="
                has_repos=1
            fi

            if [ -d "$item" ]; then
                yellow "! $name"
                echo "   .git is directory (run: git-cloud migrate \"$repo_path\")"
            elif [ -f "$item" ]; then
                local pointer
                pointer="$(cat "$item")"
                if [[ "$pointer" == gitdir:* ]]; then
                    local git_dir="${pointer#gitdir: }"
                    if [ -d "$git_dir" ]; then
                        green "✓ $name"
                    else
                        red "✗ $name"
                        echo "   Broken pointer: $git_dir"
                        if [ -f "$repo_path/$REMOTE_FILE" ]; then
                            echo "   Fix: cd \"$repo_path\" && git-cloud setup"
                        else
                            echo "   Fix: git-cloud setup <url> \"$repo_path\""
                        fi
                    fi
                fi
            fi
            ((found++)) || true
        done < <(find "$cloud_dir" -maxdepth 5 -name ".git" 2>/dev/null)

        [ $has_repos -eq 1 ] && echo ""
    done < <(each_cloud_dir)

    # Check for folders with .git-remote but no .git
    while IFS= read -r cloud_dir; do
        while IFS= read -r remote_file; do
            local repo_path
            repo_path="$(dirname "$remote_file")"
            if [ ! -e "$repo_path/.git" ]; then
                yellow "? ${repo_path#"$cloud_dir"/}"
                echo "   Has $REMOTE_FILE but no .git (run: cd \"$repo_path\" && git-cloud setup)"
                ((found++)) || true
            fi
        done < <(find "$cloud_dir" -maxdepth 5 -name "$REMOTE_FILE" 2>/dev/null)
    done < <(each_cloud_dir)

    if [ $found -eq 0 ]; then
        echo "No repos found in cloud folders."
    fi
}

# Sync local git with remote (after cloud sync brings new files)
cmd_sync() {
    local repo_path="${1:-.}"
    repo_path="$(cd "$repo_path" 2>/dev/null && pwd)" || {
        red "Error: Directory does not exist"
        return 1
    }

    # Check if it's a git repo
    if ! git -C "$repo_path" rev-parse --git-dir >/dev/null 2>&1; then
        red "Error: Not a git repository"
        echo "Run 'git-cloud setup' first"
        return 1
    fi

    local branch
    branch=$(git -C "$repo_path" branch --show-current 2>/dev/null)
    if [ -z "$branch" ]; then
        branch="main"
    fi

    local remote="origin"

    blue "Syncing with remote..."
    echo "  Branch: $branch"
    echo "  Remote: $remote"
    echo ""

    # Ensure remote tracking is configured (may be missing from old setups)
    local current_fetch
    current_fetch=$(git -C "$repo_path" config --get remote.origin.fetch 2>/dev/null || true)
    if [ -z "$current_fetch" ] || [[ "$current_fetch" != *"refs/remotes/origin"* ]]; then
        blue "Configuring remote tracking..."
        git -C "$repo_path" config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
    fi

    # Ensure branch tracking is configured
    local upstream
    upstream=$(git -C "$repo_path" config --get branch."$branch".remote 2>/dev/null || true)
    if [ -z "$upstream" ]; then
        git -C "$repo_path" branch --set-upstream-to="origin/$branch" "$branch" 2>/dev/null || true
    fi

    # Fetch latest from remote
    echo "Fetching from $remote..."
    git -C "$repo_path" fetch "$remote" || {
        red "Fetch failed"
        return 1
    }

    # Check if remote branch exists
    if ! git -C "$repo_path" rev-parse "$remote/$branch" >/dev/null 2>&1; then
        red "Error: Remote branch $remote/$branch not found"
        echo "Available remote branches:"
        git -C "$repo_path" branch -r 2>/dev/null || echo "  (none)"
        return 1
    fi

    # Show what will change
    local local_head
    local_head=$(git -C "$repo_path" rev-parse HEAD 2>/dev/null)
    local remote_head
    remote_head=$(git -C "$repo_path" rev-parse "$remote/$branch" 2>/dev/null)

    if [ "$local_head" = "$remote_head" ]; then
        green "Already in sync with $remote/$branch"
        git -C "$repo_path" status --short --branch
        return 0
    fi

    local commits_behind
    commits_behind=$(git -C "$repo_path" rev-list --count HEAD.."$remote/$branch" 2>/dev/null || echo "0")
    local commits_ahead
    commits_ahead=$(git -C "$repo_path" rev-list --count "$remote/$branch"..HEAD 2>/dev/null || echo "0")

    echo "Local is $commits_behind commit(s) behind, $commits_ahead commit(s) ahead"

    # Reset to remote
    echo ""
    yellow "Resetting to $remote/$branch..."
    git -C "$repo_path" reset --hard "$remote/$branch"

    # Fix executable permissions lost by cloud sync
    local mode_changes
    mode_changes=$(git -C "$repo_path" diff --summary 2>/dev/null | grep "mode change 100755 => 100644" || true)
    if [ -n "$mode_changes" ]; then
        echo ""
        blue "Fixing executable permissions lost by cloud sync..."
        while IFS= read -r line; do
            local file
            file="${line##*mode change 100755 => 100644 }"
            if [ -n "$file" ] && [ -f "$repo_path/$file" ]; then
                chmod +x "$repo_path/$file"
                echo "  chmod +x $file"
            fi
        done <<< "$mode_changes"
    fi

    echo ""
    green "Done!"
    git -C "$repo_path" status --short --branch
}

cmd_version() {
    echo "git-cloud $VERSION"
}

cmd_help() {
    cat << EOF
git-cloud $VERSION - Manage git repos in cloud-synced folders

SETUP (once per machine):
  1. Add to Insync/Dropbox ignore rules (directory only):
       .git/

  2. Add to your global .gitignore:
       echo ".git-remote" >> ~/.gitignore_global
       git config --global core.excludesfile ~/.gitignore_global

COMMANDS:
  git-cloud clone <url> [path]   Clone repo with .git stored locally
  git-cloud setup [url] [path]   Setup git for synced folder
  git-cloud sync [path]          Sync local git with remote after cloud sync
  git-cloud migrate [path]       Move existing .git to local storage
  git-cloud status               Show all repos and their state
  git-cloud version              Show version
  git-cloud help                 Show this help

WORKFLOW:
  Machine A (first time):
    git-cloud clone git@github.com:user/repo ~/GoogleDrive/dev/repo

  Machine B (after sync):
    cd ~/GoogleDrive/dev/repo
    git-cloud setup              # Reads URL from .git-remote

ENVIRONMENT:
  GIT_DIRS    Where to store .git dirs (default: ~/.git-dirs)
  CLOUD_DIRS  Cloud folders, colon-separated (default: ~/GoogleDrive:~/Dropbox:~/OneDrive)

More info: https://github.com/jgorostegui/git-cloud
EOF
}

# Main
case "${1:-}" in
    clone)      cmd_clone "$2" "$3" ;;
    setup)      cmd_setup "$2" "$3" ;;
    sync)       cmd_sync "$2" ;;
    migrate)    cmd_migrate "$2" ;;
    status|st)  cmd_status ;;
    version|-v|--version) cmd_version ;;
    -h|--help|help|"")    cmd_help ;;
    *)
        red "Unknown command: $1"
        echo "Run 'git-cloud help' for usage"
        exit 1
        ;;
esac
